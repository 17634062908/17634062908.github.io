<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mysql基础之事务与锁]]></title>
    <url>%2F2019%2F04%2F29%2Ftransaction-lock%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;锁是计算机协调多个进程或线程并发访问某一资源的机制。&emsp;&emsp;相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁(已过时)；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 事务与锁内容&emsp;&emsp;1. 事务&emsp;&emsp;2. innodb_flush_log_at_trx_commit&emsp;&emsp;3. 锁 &emsp;&emsp;事务其实就是并发控制的基本单位；相信我们都知道，事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位；数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清除了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。 1 事务的特性理解1234-- 查看事务日志 ：show engine innodb status\G;-- 查看日志文件设置状态show variables like 'innodb_%'; 事务日志文件 &emsp;&emsp;innodb_log_files_in_group:DB中设置几组事务日志，默认是2；&emsp;&emsp;innodb_log_group_home_dir:事务日志存放目录，不设置，ib_logfile0…存在在数据文件目录下 &emsp;&emsp;Innodb存储引擎可将所有数据存放于ibdata*的共享表空间，也可将每张表存放于独立的.ibd文件的独立表空间 &emsp;&emsp;注意：在MySQL中对于数据来说，&emsp;&emsp;最为重要的是日志文件 &emsp;&emsp;redo log =&gt; ib_logfile0 &emsp;&emsp;undo log =&gt; ibdata 1.2 原子性&emsp;&emsp;通俗的解释就是；一条绳子上的蚂蚱&emsp;&emsp;专业点：事务就是一系列的操作，要么全部都执行，要都不执行 1.2.1 回滚日志&emsp;&emsp;想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。 &emsp;&emsp;注意：系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。 &emsp;&emsp;在日志文件中:在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。 1.3 持久化&emsp;&emsp;事务被提交，数据一定会被写入到数据库中并持久存储起来，通常来说当事务已经被提交之后，就无法再次回滚了。 1.3.1 重做日志&emsp;&emsp;与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。 &emsp;&emsp;在事务写入过程 &emsp;&emsp;当我们在一个事务中尝试对数据进行写时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上，图中的第 4、5 步就是在事务提交时执行的。 1.4 回滚日志和重做日志&emsp;&emsp;到现在为止我们了解了 MySQL 中的两种日志，回滚日志（undo log）和重做日志（redo log）；在数据库系统中，事务的原子性和持久性是由事务日志（transaction log）保证的，在实现时也就是上面提到的两种日志，前者用于对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做，它们能保证两点： &emsp;&emsp;1. 发生错误或者需要回滚的事务能够成功回滚（原子性）；&emsp;&emsp;2. 在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据（持久性）； &emsp;&emsp;在数据库中，这两种日志经常都是一起工作的，我们可以将它们整体看做一条事务日志，其中包含了事务的 ID、修改的行元素以及修改前后的值。 1.5 事务日志流程&emsp;&emsp;MySQL的checkpoint https://www.cnblogs.com/lintong/p/4381578.html &emsp;&emsp;checkpoint，即检查点。在undolog中写入检查点，表示在checkpoint前的事务都已经完成commit或者rollback了，也就是检查点前面的事务已经不存在数据一致性的问题了(此处暂时不会深入解释) &emsp;&emsp;Innodb的事务日志是指Redo log，简称Log,保存在日志文件ib_logfile里面（去mysql数据目录下看下）。Innodb还有另外一个日志Undo log，但Undo log是存放在共享表空间里面的（ibdata*文件，存储的是check point日志序列号）。 &emsp;&emsp;Innodb的一条事务日志共经历4个阶段： &emsp;&emsp;1）创建阶段：事务创建一条日志；&emsp;&emsp;2）日志刷盘：日志写入到磁盘上的日志文件； （ib_logfile里面）&emsp;&emsp;3）数据刷盘：日志对应的脏页数据写入到磁盘上的数据文件；&emsp;&emsp;4）写CKP：日志被当作Checkpoint写入日志文件；（ib_data里面） 2. innodb_flush_log_at_trx_commit 参数解析12345-- 查看日志文件设置状态show variables like 'innodb_%';-- 更改set @@global.innodb_flush_log_at_trx_commit = 0; -- 0，1，2show variables like 'innodb_flush_log_at_trx_commit'; 2.1 概述 2.2 性能对比&emsp;&emsp;性能的检测办法： &emsp;&emsp;设置innodb_flush_log_at_trx_commit 不同的值，然后对比 所用的时间 2.3 数据问题对比&emsp;&emsp;因为在实际过程中很难去模拟实际的断点故障的情况，但是你可以尝试通过终止MySQL服务来测试；数据的插入速度是很快的（大量数据除外），为了方便测试这里可以对于数据插入之后睡眠一下，然后再去终止MySQL服务；就可以模拟情况；过程需要自己返回测试 &emsp;&emsp;过程 cmd 运行程序 然后 执行数据的过程中终止MySQL服务 3. 锁机制3.0 序&emsp;&emsp;如何保证数据并发访问的一致性和有效性，是所有数据库必须解决的一个问题。另外，所冲突也是影响数据库并发性能的一个重要的因素，应用程序在选择所类型时，需要根据实际运行的需要，选择最佳的所类型。 &emsp;&emsp;MySQL的不同存储引擎，支持不同的锁定机制 3.1 锁类型。&emsp;&emsp;1. MyISAM 和 Memory 存储引擎使用的是表级锁,BDB 引擎使用的是页级锁，也支持表级锁。由于 BDB 引擎基本已经成为历史，因此就不再介绍了。&emsp;&emsp;3. InnoDB 存储引擎既支持行级锁，也支持表级锁，默认情况下使用行级锁。&emsp;&emsp;4. 所谓表级锁，它直接锁住的是一个表，开销小，加锁快，不会出现死锁的情况，锁定粒度大，发生锁冲突的概率更高，并发度最低。&emsp;&emsp;5. 所谓行级锁，它直接锁住的是一条记录，开销大，加锁慢，发生锁冲突的概率较低，并发度很高。&emsp;&emsp;6. 所谓页级锁，它是锁住的一个页面，在 InnoDB 中一个页面为16KB，它的开销介于表级锁和行级锁中间，也可能会出现死锁，锁定粒度也介于表级锁和行级锁中间，并发度也介于表级锁和行级锁中间。&emsp;&emsp;7. 仅仅从锁的角度来说，表级锁更加适合于以查询为主的应用，只有少量按照索引条件更新数据的应用&emsp;&emsp;8. 行级锁更适合大量按照索引条件并发更新少量不同的数据，同时还有并发查询的应用 3.2 innoDB行级锁&emsp;&emsp;InnoDB有两种类型的行级锁，两种内部使用的意向锁；&emsp;&emsp; 共享锁(S):允许一个事务读一行数据时，阻止其他的事务读取相同数据的排他锁。&emsp;&emsp; 排他锁(X):允许获得排他锁的事务更新数据，阻止其他事务取得相同数据的共享锁和排他锁。&emsp;&emsp; 意向共享锁(IS):事务打算给数据行加行共享锁。事务在给一个数据行加共享锁前必须先取得该表的IS锁。&emsp;&emsp; 意向排他锁(IX):事务打算给数据行加行排他锁。事务在给一个数据行加排他锁前必须先取得该表的IX锁。&emsp;&emsp; 悲观锁(抽象，不真实存在的锁)&emsp;&emsp; 乐观锁(抽象，不真实存在的锁) &emsp;&emsp;4种锁的共存逻辑关系表 锁模式 共享锁(S) 排他锁(X) 意向共享锁(IS) 意向排他锁(IX) 共享锁(S) 兼容 冲突 兼容 冲突 排他锁(X) 冲突 冲突 冲突 冲突 意向共享锁(IS) 兼容 冲突 兼容 兼容 意向排他锁(IX) 冲突 冲突 兼容 兼容 &emsp;&emsp;如果一个事务请求的锁模式与当前的所模式兼容，InnoDB就将请求的锁授予该事务，如果两者不兼容，那么该事务就要等待锁释放。 &emsp;&emsp;意向锁是InnoDB存储引擎自动加的，对于普通select语句，InnoDB不会加任何锁，对于insert，update，delete语句，InnoDB会自动改涉及的数据加排他锁，InnoDB以通过以下语句显示添加的共享锁和排他锁。 &emsp;&emsp;共享锁语句 select * from table_name lock in share mode; &emsp;&emsp;排他锁语句 select * from table_name for update; 3.3 共享锁-悲观锁实例应用场景： 附带 共享锁语句 select * from table_name lock in share mode; &emsp;&emsp;注意该操作需要两个窗体一起操作 &emsp;&emsp;当执行 窗体1 执行commit的时候，窗体二才可以加排他锁 &emsp;&emsp;死锁情况：如下在 窗体1 执行共享锁之后，然后在窗体2也执行共享锁 &emsp;&emsp;在窗体1中进行数据的修改这个时候修改会等待，同时再去窗体2修改数据报错并释放锁，然后窗体1执行修改（修改成功） &emsp;&emsp;其实在窗体2的时候就是会出现死锁退出，除了死锁也会有因为等待超时而退出的情况 &emsp;&emsp;可以通过执行 select @@innodb_lock_wait_timeout查看 12345678910111213-- 窗体1代码-- START TRANSACTION;-- SELECT * FROM count WHERE prefix = 'd1' LOCK IN SHARE MODE;---- UPDATE count SET count = 4 where prefix = 'd1';-- COMMIT;-- 窗体2代码-- SELECT * FROM count WHERE prefix = 'd1';-- SELECT * FROM count WHERE prefix = 'd1' LOCK IN SHARE MODE;---- -- SELECT * FROM count WHERE prefix = 'd1' FOR UPDATE;-- UPDATE count SET count = 3 where prefix = 'd1';-- COMMIT; 排他锁语句 select * from table_name for update; 关于意向锁；&emsp;&emsp;意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。InnoDB 中的两个表锁： &emsp;&emsp;意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。如果需要对记录 A 加共享锁，那么此时 InnoDB 会先找到这张表，对该表加意向共享锁之后，再对记录 A 添加共享锁 &emsp;&emsp;意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，也就是说事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。如果需要对记录 A 加排他锁，那么此时 InnoDB 会先找到这张表，对该表加意向排他锁之后，再对记录 A 添加排他锁。&emsp;&emsp;意向锁是 InnoDB 自动加的，不需要用户干预。 &emsp;&emsp;共享锁和排他锁，系统在特定的条件下会自动添加共享锁或者排他锁，也可以手动添加共享锁或者排他锁。&emsp;&emsp;意向共享锁和意向排他锁都是系统自动添加和自动释放的，整个过程无需人工干预。 &emsp;&emsp;共享锁和排他锁都是锁的行记录，意向共享锁和意向排他锁锁定的是表。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql基础</tag>
        <tag>Mysql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础之物化视图与事务]]></title>
    <url>%2F2019%2F04%2F27%2Fview-transaction%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;物化视图，它是用于预先计算并保存表连接或聚集等耗时较多的操作的结果，这样，在执行查询时，就可以避免进行这些耗时的操作，从而快速的得到结果。物化视图有很多方面和索引很相似：使用物化视图的目的是为了提高查询性能；物化视图对应用透明，增加和删除物化视图不会影响应用程序中SQL 语句的正确性和有效性；物化视图需要占用存储空间；当基表发生变化时，物化视图也应当刷新。 1. 物化视图&emsp;&emsp;物化视图是相对于视图而言的，但是两者实际上并没有什么关系就如java/javaScript一样 &emsp;&emsp;首先mysql的视图不是一种物化视图，他相当于一个虚拟表，本身并不存储数据，当sql在操作视图时所有数据都是从其他表中查询出来的。者带来的问题是使用视图并不能将常用数据分离出来，优化查询速度，切操作视图的很多命令和普通标一样，这回导致在业务中无法通过sql区分表和视图，是代码变得复杂。 &emsp;&emsp;视图是简化设计，清晰编码的东西，他并不是提高性能的，他的存在只会降低性能（如一个视图7个表关联，另一个视图8个表，程序员不知道，觉得很方便，把两个视图关联再做一个视图，那就惨了），他的存在未了在设计上的方便性 &emsp;&emsp;物化视图可以帮助加快严重依赖某些聚合结果的查询。如果插入速度不是问题，则此功能可以帮助减少系统上的读取负载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798select count(*),sum(pro_price), sum(pro_num),avg(pro_price), avg(pro_num) from purchase_order物化视图 可以理解成 就是单独再创建一张统计表吗把数据记录 select count(*),sum(pro_price), sum(pro_num),avg(pro_price), avg(pro_num) from purchase_order =&gt;&gt; purchase_mv根据项目的需求 (数据实时性)要定时更新数据, ==&gt;&gt; 存储过程 call开销小,误差大一点中间表 使用视图是避免因为 purchase_mv 表的结果修改,而影响到存储过程与触发器的查询sql语句的修改create view por_view as select supply_name, count(*) pro_count, sum(pro_price) pro_price_sum, avg(pro_price) pro_price_avg, sum(pro_num) pro_num_sum, avg(pro_num) pro_num_avg from purchase_order group by supply_name;定时执行这样的sqlinsert into purchase_mv select * from por_view;第一步获取 需要获取原有统计数据 select * from por_view第二步写入 purchase_mvDROP PROCEDURE refresh_mv_now;DELIMITER $$CREATE PROCEDURE refresh_mv_now ()BEGIN TRUNCATE TABLE purchase_mv; INSERT INTO purchase_mv SELECT * FROM por_view;END;$$DELIMITER ;select * from purchase_mv;定时执行下面的sql,你可以使用你所会的方法call refresh_mv_now ();实时更新数据, ==&gt;&gt; 触发器 使用触发器,是很会影响数据库的写操作的性能开销大drop trigger purchase_mv_trigger_ins;DELIMITER $$CREATE TRIGGER purchase_mv_trigger_ins AFTER INSERT ON purchase_order FOR EACH ROWBEGIN SET @old_pro_price_sum = 0; SET @old_pro_price_avg = 0; SET @old_pro_num_sum = 0; SET @old_pro_num_avg = 0; SET @old_pro_count = 0; # 查询出之前的信息然后记录到不同的变量中 SELECT IFNULL(pro_price_sum,0),IFNULL(pro_price_avg,0), IFNULL(pro_num_sum,0),IFNULL(pro_num_avg,0), IFNULL(pro_count,0) FROM purchase_mv WHERE supply_name = NEW.supply_name INTO @old_pro_price_sum,@old_pro_price_avg,@old_pro_num_sum,@old_pro_num_avg,@old_pro_count; # 然后再去计算更新操作之后的内容 SET @new_pro_count = @old_pro_count + 1; SET @new_pro_price_sum = @old_pro_price_sum + NEW.pro_price; SET @new_pro_price_avg = @new_pro_price_sum / @new_pro_count; SET @new_pro_num_sum = @old_pro_num_sum + NEW.pro_num; SET @new_pro_num_avg = @new_pro_num_sum / @new_pro_count; REPLACE INTO purchase_mv VALUES( NEW.supply_name, @new_pro_count, @new_pro_price_sum, IFNULL(@new_pro_price_avg, 0), @new_pro_num_sum, IFNULL(@new_pro_num_avg, 0) );END;$$DELIMITER ;= 表可能会改变CREATE TABLE purchase_mv( supply_name VARCHAR(60) NOT NULL , pro_count INT NOT NULL, pro_price_sum INT NOT NULL, pro_price_avg FLOAT NOT NULL, pro_num_sum INT NOT NULL, pro_num_avg FLOAT NOT NULL, UNIQUE INDEX supply_name (supply_name));物化视图 -&gt; 存储过程 和 触发器的 综合应用表的数据大 : 有些内容很频繁查询 1.2 存储过程与触发器区别是？&emsp;&emsp;存储过程 =&gt; 主动 技能 ( 函数 )&emsp;&emsp;触发器 =&gt; 被动 技能 ( 函数 ) 2. 事务:1.0 MyISAM实现事务&emsp;&emsp;通过表锁实现伪事务 1.1 事务的概念&emsp;&emsp;事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永远更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复病史应用程序更加可靠。一个逻辑共奏单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性： 原子性（A） 对于数据修改，要么全部都执行，要么全都不执行。 隔离性（C） 在所有的操作没有执行完毕之前，其他会话不能够看到中间改变的过程。 一致性（I） 事务发生前和发生后，根据数据的规则，总额应该匹配。 持久性（D） 事务一旦被提交，其结果就是永久性的，系统崩溃也不会影响 &emsp;&emsp;应用场景:使用场景一般涉及到个人财务信息的时候都会使用到，比如上图的积分计算,还有订单购物车等 1234start transaction; 开启事务insert into count (prefix,count,historyCount)values('dyi', 0, 2);select * from countcommit; 1.4 事务的实现 – （类似电影《预知未来》）&emsp;&emsp;存储引擎简单瞧瞧后面细讲 &emsp;&emsp;因为MySQL5之后通常的默认存储引擎是InnoDB所以，以InnoDB为例讲解实现过程 &emsp;&emsp;MySQL在进行事务处理的时候使用的是日志现行的方式来保证事务可快速和持久运行的，也就是在写数据库前，需要先写日志。当开始一个事务时，会记录该事物的一个LSN日志序列号；当执行事务时，会往InnoDB_Log_Buffer 日志缓冲区里插入事务日志（redo log）;当事务提交时，会将日志缓存区里的事务日志刷入磁盘。这个动作主要是由innodb_flush_log_at_trx_commit这个参数控制的。 发出commit动作时。已经说明过，commit发出后是否刷日志由变量 innodb_flush_log_at_trx_commit 控制。 每秒刷一次。这个刷日志的频率由变量 innodb_flush_log_at_timeout 值决定，默认是1秒。要注意，这个刷日志频率和commit动作无关。 当log buffer中已经使用的内存超过一半时。 当有checkpoint时，checkpoint在一定程度上代表了刷到磁盘时日志所处的LSN位置。 &emsp;&emsp;可以通过命令1show engine innodb status\G; Log sequence number 8619676075 (表示当前的LSN日志序列号)Log flushed up to 8619676075 (表示刷新到事物日志的LSN日志序列号)Last checkpoint at 8619676075 (表示刷新到磁盘的LSN日志序列号) &emsp;&emsp;除了记录事务日志意外，数据库还会记录一定量的撤销日志(undo log)， undo与redo正好相反，在对数据进行修改时，由于某种原因失败了，或者人为执行了rollback回滚语句，就可以利用这些撤销日志将数据回滚到修改之前的样子。redo日志保存在ib_logfile0/1/2里，而undo日志保存在ibdata1里，在MySQL5.6里还可以把undo日志单拆分出去。 1.5 分布式事务（了解）&emsp;&emsp;资源管理器：管理事务的提交和回滚，向事务提供资源。&emsp;&emsp;事务管理器：和资源管理器通信，协调完成事务的处理。 &emsp;&emsp;用于执行分布式事务的过程使用两个阶段；（1）第一阶段：所有的分支被预备。他们被事务管理器告知要准备提交，每个分支资源管理器记录分支的行动并指示认为的可行性。（2）第二阶段：事务管理器告知资源管理器是否要提交或者回滚。如果预备分子时，所有的分支指示他们将能够提交，那么所有的分支被告知提交。如果有一个分支出错，那么就全部都要回滚。特殊情况下，只有一个分支的时候，第二阶段则被省略。 &emsp;&emsp;分布式事务主要作用在于确保事务的一致性和完整性。他利用分布式的计算环境，将多个事务性的活动合并成一个事务单元，这些事务组合在一起构成原子操作，这些事务的活动要么一起执行并提交事务，要么回滚所有的操作，从而保证了多个活动之间的一致性和完整性。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql基础</tag>
        <tag>Mysql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追寻本质还是流于形式]]></title>
    <url>%2F2019%2F04%2F24%2Fwork%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多人说编程是艺术。我不否认这句话，但编程和“八大艺术”有最根本的区别：艺术的形式极为重要，但编程形式却不是那么的重要。&emsp;&emsp;追寻事物本质应该是人类与生俱来的一种特性。看看我们在童年时向我们父母提出的那些啼笑皆非的问题，再想想我们小时候拿着放大镜对着一白纸在正午的烈日下一蹲就是一小时，只是为了去点燃这张纸。那是童年最原始、最纯真的对于真理和本质追寻的行为。 &emsp;&emsp;可20多岁的我们，却丧失了这种最纯真的好奇心。我们醉心于那些表面的、外在的、甚至是虚无的成就感。我们每天循环着尝试使用各种工具解决各种问题，以此来换取一些微薄的酬劳。我们会用各种不同的编程手法、不同的思维来解决同一个问题，以此来判别你与竞争对手的水平高低；我们也会彼此竞争式的学习更多的语言、更好的框架、更新的技术，可我们所谓的学习，却仅仅只是“会用”。 &emsp;&emsp;时间久了，累了，厌倦了，就觉得没有意思了。 &emsp;&emsp;你迷茫了。迷茫是再正常不过的了。跟着形式跑，看不到事物的本质，你永远会觉得疲倦。 &emsp;&emsp;很多人说编程是艺术。我不否认这句话，但编程和“八”大艺术（第八大艺术是电影，这个还有不少争论）有最根本的区别：艺术的形式极为重要，但编程形式却不是那么的重要。 &emsp;&emsp;拿电影来举例，很多经典的电影其实核心内容是及其简单的，或者说导演想表达的内心世界也无非就是：人性本善/本恶、奋斗出奇迹、爱情诚可贵、自由价更高等常规主题。但经典电影之所以伟大，就在于导演会用非常规的叙事手法，奇妙的镜头语言，符合人物内心的光影特效来完成一部出色的电影。道理总有讲完的一天，但艺术之所以具有长久的生命力和创造力，或许就在于形式的百花齐放。你会担心这世界上由于题材的枯竭而再也写不出小说或者拍不出电影吗？ &emsp;&emsp;不会。爱情都是同样的爱情，但表现爱情的手法却永远取之不竭，用之不尽。 &emsp;&emsp;可编程不同。你用面向对象还是面向过程，亦或是是否使用设计模式，这都远远不能掩盖一个事实：你只是解决了同一个问题。 &emsp;&emsp;那编程的形式重要吗？ &emsp;&emsp;编程中的形式远没有形式之于艺术重要。问题在于目的的不同：艺术更多时候是为了去表现，让人们感受形式的美好；但编程的根本目的不在于形式，而在于解决问题。 &emsp;&emsp;如果你太在意编程中的形式，而忽略了编程中的“本质”，这实在是不可取的。形式大多充满变化，描述一个爱情故事可以用诗词赋、可以用电影、可以用绘画，而每种艺术载体在描述爱情时，又可以幻化出千奇百怪的手法。同样，解决一个问题，可以用A语言、也可以用B语言、C语言、D语言、J语言，可以用F框架、可以用D框架、可以用T框架。 &emsp;&emsp;可问题是，这些不同的语言和框架真的对于解决问题是如此的重要吗？也许你会举出开发效率、性能等千万条理由来反驳我，但你忽略了一个本质，他们没有改变这些不同的语言和框架都只是解决了同一个问题的本质。过分追求这种不同语言、不同框架的形式，对一个程序员来说是极为不正确的。 &emsp;&emsp;我们这个社会里的很多媒体对于技术的引导是不正确的。一个月学会大数据的真实意思是你只学会了大数据API的调用，现在大数据不热了，你又开始追寻机器学习和区块链了。可这大数据也好、AI、区块链也好，这都是形式。 &emsp;&emsp;你不断盲目的去学习形式，只是因为你内心的贪婪和焦虑。这个时代正在以疯狂的速度肆无忌惮的制造新产品：每天都有无数的楼房拔地而起，每天都有几百本书籍出版，每天也有很多的新技术、新语言在酝酿。 &emsp;&emsp;于是你很焦虑，害怕被这个时代淘汰。这种焦虑诱发出了人类的本性：贪婪。我们疯狂的购买书籍、购买课程、购买一切看上去可以让我们成长的物件，数量变成了这个时代知识的计量单位，数量可以满足我们的贪婪，同时又在一定程度上解决我们的焦虑。 &emsp;&emsp;但你是跑不过这个时代形式的变化的。时代的形式是由千千万万比你还优秀的人共同缔造的，而你只是其中的一个个体，你如何以一抵万？ &emsp;&emsp;其实无需太过于恐惧变化，大多数事物发展的规律是由量变转化成质变，你要担心的是质变，而一个时代要想产生革命性的质变，这需要的时间太漫长了。你实在无需为形式的变化烦恼太多。 &emsp;&emsp;任何一项技术或者产品的制造都是一条链式的，越是链条的头部，所获取的资源越多，所牟取的利益越大。你看到lenvo的电脑卖的很好，但你需要知道intel的CPU卖的更好，他掌握了链条的头部资源和技术，而这些技术具备一定的普适性，他即可以把CPU卖给联想也可以卖给弘基。因特尔靠技术赚钱的实质在于，他抓住了计算机制造业里的“本质”。 &emsp;&emsp;再比如现在大量的茶水连锁，掌握茶的制作工艺的头部技术拥有者才能撑起这个链条，做起各种加盟。头部的核心本质掌握，让这些技术的拥有者形成一种辐射效应，每一个辐射出去的链条，源头都在辐射的核心点。 &emsp;&emsp;放到编程这个行业也是一样。越接近本质，收益越高。你会发现，做算法的收入远比做业务的要高，搞C语言的大多数情况下的平均收入都要高于搞PHP、Java的；而那些能做AI、机器学习的也是因为他们掌握了大量智能领域的本质算法和模型，而绝对不是因为他们会Python。 &emsp;&emsp;有些人就是比你更接近事物和原理的本质，他们是辐射的核心，你只是他的一个加盟商。资源和利益会随着辐射链条的延长而逐渐趋于稀薄。 &emsp;&emsp;去探寻下本质，去深挖一下语言的特性，框架的原理，多去学学算法与数据结构，多去复习下早已遗忘的数学，这真的是个不错的选择。从编程的角度来看，很多的框架也好语言也好，都只是形式在变，但他就是旧瓶装新酒啊。 &emsp;&emsp;童年的那份好奇心，那些对事物本质追寻的可笑问题，可能我们是再也找不回来了。也许这也就是为什么童年弥足珍贵的原因。但你依然需要记住，追寻本质才是这个不断变化的时代最有效的生存守则。 &emsp;&emsp;你看，其实我这篇文章也只是讲了一个浅显的道理。所以，形式重要吗？对文学来说很重要，但至于现实，形式屁都不是。 作者：7七月链接：http://www.imooc.com/article/24509来源：慕课网]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>职业生涯</tag>
        <tag>技术规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迟到的博客]]></title>
    <url>%2F2019%2F04%2F23%2Fblog%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;自己做一年半技术的一点感悟…&emsp;&emsp;在上学期间就有建个人博客的想法，但苦于当时学艺不精，能力不佳，迟迟没有着手(又是个为懒惰找借口的家伙)，随着对PHP越来越深入的接触，发现他所涉及的领域也越开越广，除了基础三大框架TP、Yii、Laraval的熟练掌握与应用，PHP的魔爪更伸向微信开发、小程序开发、接口开发、各种支付等等，比较遗憾的是多数程序员还只是代码搬运工的思维，他们只考虑这个东西怎么用，而从来没有深入研究过这个技术实现原理是什么，所以他们在使用工具上疲于奔命，似乎有学不完的框架，做不完的笔记。&emsp;&emsp;依我看来，问题的症结还是在于基础知识不太扎实，基础概念很多还是含糊不清，比如在学面向对象的时候觉得很空洞不知道一个类一个对象能用来干什么，但用框架的时候后又全是没见过面向对象用法，所以当这两个结果摆在你面前时你就能看到自己在OOP知识层面的差距，，而弥补减少知识差距的唯一方式就是学习他、研究他、使用他！例如学面向对象时并没有学反射机制，但是框架中框架却用他做了很多事情，这时就需要你花时间去学习他，一次次的探究，一次次的深入，遇到新的没见过的知识返回去查手册，再次巩固并加深自己基础知识，下一次遇到新的知识点再按此方法学习再学习，让自己的代码，思路，想法，逻辑一步步往框架层面靠拢，假设，印证，推翻，再进一步假设周而复始，最终把知识内化到头脑里去。&emsp;&emsp;所以本博客创立的目的不仅仅是用于笔记的整理归纳，更多的是深入框架，源码底层去扒一扒那些鲜为人知的高端技术，可能在我们日常开发中，很少去用到，但是他会让你用工具越来越得心应手，思路越来越开阔，更能让你把PHP语言运用到极致(这牛逼吹的有点大)。这样把最核心的技术学到，在学习新的知识时方能有一点即通之效，你不用再为诸多框架而烦恼不堪，能腾出更多的时间、更多的精力、更加专注的写自己BUG了，哇哈哈哈哈~&emsp;&emsp;（PS：一味的鼓吹“高端技术”，也不是贬低那些为框架焦头烂额的人，闻道有先后，术业有专攻，每个人的能力层次虽然不一样，但我们不能只安于现状，优秀的开发产品值得我们去研究去学习，他里面所折射出的解决问题的方法至少成为我们解决实际问题的一种思路，虽然过程很痛苦，但终究会抵达，有一天羽翼丰满的你终将在PHP的世界里驰骋遨游！）]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础之视图、触发器、存储过程]]></title>
    <url>%2F2019%2F04%2F23%2Fstored-view-trigger%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我学习视图,存储过程,及触发器的]时候,将书上的示例进行整理,写下了这样一篇文章,用记录了当时学习的过程,也希望可以解除一部分人对这方面的疑惑… 面试题面试你所要知道的:MySQL存储过程 https://blog.csdn.net/u012190514/article/details/80282161 序言mysql 的CURD的基础内容在这里就跳过，关于select，update，delete，insert的基础使用以及select的复杂查询在本节中将会跳过 课程内容 视图 存储过程 触发器 数据表结构数据 1. 视图1.1 概念 视图是 MySQL 在 5.0.1 版本中加入的功能。它可以理解为一个虚表。 之所以被称为虚表，是因为它只是存储了一个结构，并不存储真实的数据。它的数据是在查询过程中动态生成的。 视图并不是真的优化 1.2 创建视图视图 只是存储了一个结构，并不存储真实的数据。12-- 创建视图create VIEW user_view as select id,user_name,email from `user`; 1.3 查看视图和表一样，我们可以用 desc 视图名;来查看视图的每一列 12345desc user_view;-- 查看创建的视图语法show create view user_view;-- 查询视图内容select * from user_view; &gt; 注意：视图查询的数据实则来自与源数据中的内容，而它本质是一个存储了一个结构，并不是存储真实的数据。 &gt; 比如：如同PHP中的一个查询方法的封装 123456789&lt;?phpclass db&#123; public function select() &#123; return 'sql: select id,user_name,email from `user`' &#125;&#125;?&gt; 1.4 视图优点 第一个显著优点就是它简化了操作。此时我们完全不用关心视图是怎么处理数据的，我们只需要知道如何使用这个结果集即可，视图相当于一个中间层。 第二个显著优点就是它更加安全。比如我们可以让用户有权去访问某个视图，但是不能访问原表，这样就可以起到保护原表中某些数据的作用。 我们之后会接触到管理权限，权限是无法细致到某一个列的，通过视图，则很容易实现。 第三个显著优点就是降低耦合。假如我们以后要修改原表的结构，那么我们可以通过修改视图的定义即可，而不用修改应用程序，对访问者是不会造成影响的，一般来说，这样代价会更小。1.5 视图缺点 表结构修改则需要手动修改视图 1.6 视图IUD表是可以更新数据的，这里的更新，指的是”增删改”,但是对于视图来说 不一定。 1234update `user` set email = 00 where id = 12;select * from user_view;-- 删除视图DROP VIEW user_view_2; 以下是视图不可更新的情况 包含聚合函数、distinct、group by、having、union、union all。 常量视图。 select 包含子查询。 包含连接操作。 from 一个不能更新的视图。 where 子句的子查询引用了 from 子句中的表。 自个测试… 更新视图的注意点如下数据创建一个新的视图 12create view user_view_2 as select id,user_name,password,email,status from `user` where status = 0;select * from user_view_2; 现在如果给这个视图新增数据 status = 1； 123insert into user_view_2(id, user_name, password, email, status) values (30, '221', '12', '12', 1);select * from user_view_2;select * from `user`; 你会发现我们可以向该视图插入数据，它不满足本视图的要求，但是数据可以插入基表了。在前面也有所讲过该操作有点类似于PHP的代码封装的操作。我们把该视图的操作转化为PHP 方法就是如下 123456&lt;?phpfunction select()&#123; if ($status == 0) &#123; return "sql: select id,user_name,password,email,status from `user` where status = 0"; &#125;&#125;?&gt; 但是有些时候的我们不希望这种情况的发生，如果不满足视图的条件就不插入，就和PHP方法的条件判断一样12345&lt;?phpif ($status == 0) &#123; return 'insert';&#125;?&gt; with check option 对于上面的表 t2，我们想：是否可以创建一个视图，它只允许修改满足本视图要求的数据，而对于不满足本视图要求的数据操作，统统拒绝呢？ 答案是肯定的。那就需要 with check option 了，不过该修饰符还有更加深一步的权限机制。 首先我们还是利用上一步的 t2，我们创建一个视图 v3，它的创建123DROP VIEW user_view_2;create view user_view_2 as select id,user_name,password,email,status from `user` where status = 0 with check option;insert into user_view_2(id, user_name, password, email, status) values (31, '221', '12', '12', 1); 错误信息[Err] 1369 - CHECK OPTION failed &#39;community.user_view_2&#39; 这里可以理解为 with check option 的作用就是多了一个 check 的功能，即检查的功能，也就是说插入的数据必须满足该视图的条件，才允许被操作。 1.7 视图应用&amp;好处 提高了重用性，就像一个函数如果要频繁获取user的name和goods的name。就应该使用以下sql语言。示例： &amp;nbsp; &amp;nbsp; &amp;nbsp; select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;&lt;br&gt; 但有了视图就不一样了，创建视图other。示例 &amp;nbsp; &amp;nbsp; &amp;nbsp; create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;&lt;br&gt; 创建好视图后，就可以这样获取user的name和goods的name。示例： &amp;nbsp; &amp;nbsp; &amp;nbsp; select * from other;&lt;br&gt; 以上sql语句，就能获取user的name和goods的name了。 对数据库重构，却不影响程序的运行假如因为某种需求，需要将user拆房表usera和表userb，该两张表的结构如下&nbsp; &nbsp; &nbsp;测试表:usera有id，name，age字段&nbsp; &nbsp; &nbsp;测试表:userb有id，name，sex字段这时如果php端使用sql语句：select from user;那就会提示该表不存在，这时该如何解决呢。解决方案：创建视图。以下sql语句创建视图：&nbsp; &nbsp; &nbsp; create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;以上假设name都是唯一的。此时php端使用sql语句：select from user;就不会报错什么的。这就实现了更改数据库结构，不更改脚本程序的功能了。 提高了安全性能。可以对不同的用户，设定不同的视图。例如：某用户只能获取user表的name和age数据，不能获取sex数据。则可以这样创建视图。示例如下：&nbsp; &nbsp; &nbsp; create view other as select a.name, a.age from user as a;这样的话，使用sql语句：select * from other; 最多就只能获取name和age的数据，其他的数据就获取不了了。 让数据更加清晰想要什么样的数据，就创建什么样的视图。经过以上三条作用的解析，这条作用应该很容易理解了吧 2. 触发器1.创建触发器：1234567触发器 类似于 框架 事件create trigger [触发器名称] [触发器的执行时间] [执行的动作点] on [表名] for each row [函数 或者动作]触发器的执行时间 :before, after执行的动作点:insert, update, delete函数:begin end;或者动作:update ,insert 2.1 案例：1234567891011create trigger login_trigger_beforebefore insert on loginfor each rowbegin update test_trigger set count = count+1 where id =1; -- 代码区域end;insert into login_view (id,name)values(50,'uuu'); 3. 存储过程对数据进行计算，分析汇总的时候，尤其是拿到别的公司数据的时候，进行转换为自己系统需要的数据和格式的时候 3.1 概念存储过程和函数可以理解为一段 SQL 语句的集合，它们被事先编译好并且存储在数据库中。在 Pascal 语言中，是有”过程”和”函数”的区分的，过程可以理解为没有返回值的函数。不过在 C 家族语言中，则没有过程这个概念，统一为函数。 创建一个存储过程的语法为：123456create procedure 存储过程名(参数列表)begin 存储过程体endcall 存储过程名(参数列表) 如下简单存储过程1234567DROP PROCEDURE user_procedure;create PROCEDURE user_procedure(in x int) -- in 表示输入BEGIN select * from `user` where id = x;END-- 执行call user_procedure(1); 参数类型 从上面的过程中我们了解到存储过程有参数类型这种说法，它的类型可以取值有三个：in、out、inout。 其中它们的意义如下：(1) in 表示只是用来输入。(2) out 表示只是用来输出。(3) inout 可以用来输入，也可以用作输出。12345678DROP PROCEDURE user_procedure_out;create PROCEDURE user_procedure_out(in x int, out y varchar(10))BEGIN select user_name into y from `user` where id = x;END-- 执行call user_procedure_out(1, @a);select @a 3.2 存储过程理解 调用存储过程与直接执行 SQL 语句的效果是相同的，但是存储过程的一个好处是处理逻辑都封装在数据库端。 当我们调用存储过程的时候，我们不需要了解其中的处理逻辑，一旦处理逻辑发生变化，只需要修改存储过程即可，对调用它的程序完全无影响。 调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率1show create PROCEDURE user_procedure_out; 3.3 变量 存储过程中是可以使用变量的，我们可以通过 declare 来定义一个局部变量，该变量的作用域只是 begin….end 块中。 变量的定义必须写在符合语句的开头，并且在任何其他语句的前面。我们可以一次声明多个相同类型的变量，我们还可以使用default 来赋予默认值。 定义一个变量的语法为：declare 变量名 1 [,变量名 2…] 变量类型 [default 默认值] 上面的变量类型就是 MySQL 支持的类型，而变量名的取值规则也是一个老生常谈的话题了，就不赘述了。 变量可以直接赋值，还可以通过查询赋值。 直接赋值就是使用 set 来进行赋值，它的语法为：set 变量名 1 = 表达式 1 [,变量名 2=表达式 2…] 也可以通过查询来将结果赋值给变量，它需要要求查询返回的结果只有一行，语法范例：select 列名列表 into 变量列表 from 表名 其他语句； 12345678910DROP PROCEDURE user_procedure_2;create PROCEDURE user_procedure_2(in x int, out y varchar(10))BEGIN declare s varchar(10) ; select user_name into s from `user` where id = x; set y = s;END-- 执行call user_procedure_2(1, @a);select @a 3.4 存储过程中的数据类型 数值类型：Int,float,double,decimal 日期类型：timestamp,date,year 字符串：char,varchar,text timestamp: 是使用最多的数据类型-》十位数的时间戳text：一旦用到text类型的时候就可以考虑分表；如果部分表的话，该字段的查询不会直接放在一起查询，因为多个字段查询中其中如果有text字段的话，就容易遇到慢查询所以通常的话，如果需要这个值的时候会根据id单独拿这个text字段 3.5 流程控制语句其他语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950if 的语法格式为：if 条件表达式 then 语句 [elseif 条件表达式 then 语句] .... [else 语句]end ifcase 的语法格式首先是第一种写法：case 表达式 when 值 then 语句 when 值 then 语句 ... [else 语句]end case然后是第二种写法：case when 表达式 then 语句 when 表达式 then 语句 .... [else 语句]end caseloop 循环 语法格式为：[标号:] loop 循环语句end loop [标号]whilewhile a&gt;100 do 循环语句End whileRepeat //游标 SQL语句1 UNTIL 条件表达式END Repeat;Loop SQL语句 所有的条件判断和跳出需要自己实现End loopleave 语句用来从标注的流程构造中退出，它通常和 begin...end 或循环一起使用leave 标号;声明语句结束符，可以自定义:DELIMITER [符合]delimiter $$$$ 3.6 游标 游标也有的资料上称为光标。 我们可以在存储过程中使用游标来对结果集进行循环的处理。 游标的使用步骤基本分为：声明、打开、取值、关闭。 语法：1234DECLARE test_cursor CURSOR FOR 结果集; //声明游标OPEN test_cursor; //打开游标CLOSE test_cursor; //关闭游标DECLARE CONTINUE HANDLER FOR NOT FOUND //结果集查询不到数据自动跳出 总结： 游标的声明的语法：declare 游标名称 cursor for 查询语句; 打开光标的语法：open 游标名称; 获取游标数据：fetch 游标名称 into 变量名 1 [,变量名 2 ….] 关闭游标的语法：close 游标名称; 游标的基本使用须知：对某个表按照循环的处理，判断循环结束的条件是捕获 not found 的条件，当 fetch 光标找不到下一条记录的时候，就会关闭光标然后退出过程。 可能有过 Pascal 编程经验的朋友们都会知道，声明的顺序也是很重要的，在 SQL 中，我们使用 declare 定义的顺序是：变量、条件、游标、应用程序 操作查询出来的数据会放置于临时表中，然后再通过游标去读取数据。 案例123456789101112131415161718192021222324252627282930delimiter $$create procedure exchange(out count int )begin declare supply_id1 int default 0; declare amount1 int default 0; -- 游标标识 declare blag int default 1; -- 游标 declare order_cursor cursor for select supply_id,amount from order_group; -- not found 这个异常进行处理 declare continue handler for not found set blag = 0; set count = 0; -- 打开游标 open order_cursor; -- 遍历 read_loop: LOOP fetch order_cursor into supply_id1,amount1; if blag = 0 then leave read_loop; end if; if supply_id1 = 1 then set count = count + amount1; end if; end loop read_loop;end;$$delimiter ;call exchange(@count);select @count; 存储过程优点 第一点优势就是执行速度快。因为我们的每个 SQL 语句都需要经过编译，然后再运行，但是存储过程都是直接编译好了之后，直接运行即可。 第二点优势就是减少网络流量。我们传输一个存储过程比我们传输大量的 SQL 语句的开销要小得多。 第三点优势就是提高系统安全性。因为存储过程可以使用权限控制，而且参数化的存储过程可以有效地防止 SQL 注入攻击。保证了其安全性。 第四点优势就是耦合性降低。当我们的表结构发生了调整或变动之后，我们可以修改相应的存储过程，我们的应用程序在一定程度上需要改动的地方就较小了。44 / 123 第五点优势就是重用性强。因为我们写好一个存储过程之后，再次调用它只需要一个名称即可，也就是”一次编写，随处调用”,而且使用存储过程也可以让程序的模块化加强。 3.7 存储过程的缺点 第一个缺点就是移植性差。因为存储过程是和数据库绑定的，如果我们要更换数据库之类的操作，可能很多地方需要改动。 第二个缺点就是修改不方便。因为对于存储过程而言，我们并不能特别有效的调试，它的一些 bug 可能发现的更晚一些，增加了应用的危险性。 第三个缺点就是优势不明显和赘余功能。对于小型 web 应用来说，如果我们使用语句缓存，发现编译 SQL 的开销并不大，但是使用存储过程却需要检查权限一类的开销，这些赘余功能也会在一定程度上拖累性能。 3.8 php中的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phprequire_once 'db.php';// $sql = 'create procedure login_procedure_4 (in id int, out ret varchar(10))// begin// declare y int default 0;// select shop_name into ret from shop where uid = id;// set ret = "ttt";// if y = 0 then// set ret = "xxxxx";// end if;// end';// $db-&gt;execute($sql);// $sql = 'call login_procedure_3(87, @ret)';// var_dump($db-&gt;call($sql, 'select @ret'));// echo '成功';// 游标// 1. 声明/*declare xxxdeclare 游标名 cursor for 查询语句 [select xx,xx,x,x from table_name];open 游标名 -- 打开fetch 游标名 into xxx,业务处理close 游标名 */ $sql = ' create procedure login_procedure_5 (in id int, out ret varchar(10)) begin declare id int default 0; -- 游标标识 declare blag int default 1; declare name varchar(10) default 0; declare shop_cursor cursor for select shop_name,uid from shop; -- 异常处理 :注意游标在读取数据的时候,不断读取 declare continue handler for not found set blag = 0; open shop_cursor; -- 打开 read_loop:loop fetch shop_cursor into name,id; if blag = 0 then leave read_loop; end if; if id = 63 then set ret = name; end if; end loop read_loop; end'; // $db-&gt;execute($sql); $sql1 = 'call login_procedure_5(87, @ret)'; var_dump($db-&gt;call($sql1, 'select @ret')); echo '成功'; ?&gt; 3.9 小结 存储过程和函数的优势是可以将数据的处理放在数据库服务器上进行，避免将大量的结果集传输给客户端，减少了数据的传输，因此也减少了宽带和服务器的压力。 但是在数据库服务器上进行大量的运算也会占用服务器的 CPU，造成数据库服务器的压力。 一般来说是不建议在存储过程中进行大量的复杂的运算的，它们不是数据库服务器的强项，我们应该把这些操作让应用服务器去处理。 3.10 例子 可以尝试用存储过程实现一下不用在以数据量 3. 物化视图物化视图是相对于视图而言的，但是两者实际上并没有什么关系就如java/javaScript一样 首先mysql的视图不是一种物化视图，他相当于一个虚拟表，本身并不存储数据，当sql在操作视图时所有数据都是从其他表中查询出来的。者带来的问题是使用视图并不能将常用数据分离出来，优化查询速度，切操作视图的很多命令和普通标一样，这回导致在业务中无法通过sql区分表和视图，是代码变得复杂。 视图是简化设计，清晰编码的东西，他并不是提高性能的，他的存在只会降低性能（如一个视图7个表关联，另一个视图8个表，程序员不知道，觉得很方便，把两个视图关联再做一个视图，那就惨了），他的存在未了在设计上的方便性 物化视图可以帮助加快严重依赖某些聚合结果的查询。如果插入速度不是问题，则此功能可以帮助减少系统上的读取负载。 物化视图:触发器,存储过程,变量 创建一个实体的表 物化视图 表记录:查询的结果, 查询 物化视图 表 ==&gt;聚合结果集 数据:实时性一致性 触发器 INSERT UPDATE DELTE 物化视图 定时 对存储过程 存储过程的应用:OA,ERP对数据进行计算,分析汇总,]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql基础</tag>
        <tag>Mysql优化</tag>
      </tags>
  </entry>
</search>
